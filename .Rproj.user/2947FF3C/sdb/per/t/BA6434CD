{
    "contents" : "---\ntitle       : Shiny Lecture 2 (Shinier)\nsubtitle    : Data Products\nauthor      : Brian Caffo, Jeff Leek, Roger Peng\njob         : Johns Hopkins Bloomberg School of Public Health\nlogo        : bloomberg_shield.png\nframework   : io2012        # {io2012, html5slides, shower, dzslides, ...}\nhighlighter : highlight.js  # {highlight.js, prettify, highlight}\nhitheme     : tomorrow      # \nurl:\n    lib: ../../librariesNew\n    assets: ../../assets\nwidgets     : [mathjax]            # {mathjax, quiz, bootstrap}\nmode        : selfcontained # {standalone, draft}\n---\n\n## Shiny revisited\n* In the last lecture, we covered basic creation of \nShiny applications\n* If you tried it and are like most, you had an easy time with `ui.R`\nbut a harder time with `server.R`\n* In this lecture, we cover some more of the details of shiny\n* Since writing the last lecture, a more detailed tutorial has\nbeen created that is worth checking out\n(http://shiny.rstudio.com/tutorial/)\n\n\n---\n## Details\n* Code that you put before `shinyServer` in the `server.R` function gets\ncalled once when you do `runApp()`\n* Code inside the unnamed function of `shinyServer(function(input, output){` but\nnot in a reactive statement will run once for every new user (or page refresh) \n* Code in reactive functions of `shinyServer` get run repeatedly as needed\nwhen new values are entered (reactive functions are those like `render*`)\n\n---\n### Experiment (code in the slidify document)\n`ui.R`\n\n```\nshinyUI(pageWithSidebar(\n  headerPanel(\"Hello Shiny!\"),\n  sidebarPanel(\n      textInput(inputId=\"text1\", label = \"Input Text1\"),\n      textInput(inputId=\"text2\", label = \"Input Text2\")\n  ),\n  mainPanel(\n      p('Output text1'),\n      textOutput('text1'),\n      p('Output text2'),\n      textOutput('text2'),\n      p('Output text3'),\n      textOutput('text3'),\n      p('Outside text'),\n      textOutput('text4'),\n      p('Inside text, but non-reactive'),\n      textOutput('text5')\n  )\n))\n\n```\n\n---\n`server.R`\nSet `x <- 0` before running\n```\nlibrary(shiny)\nx <<- x + 1\ny <<- 0\n\nshinyServer(\n  function(input, output) {\n    y <<- y + 1\n    output$text1 <- renderText({input$text1})\n    output$text2 <- renderText({input$text2})\n    output$text3 <- renderText({as.numeric(input$text1)+1})\n    output$text4 <- renderText(y)\n    output$text5 <- renderText(x)\n  }\n)\n```\n\n---\n## Try it\n* type `runApp()` \n* Notice hitting refresh increments `y` but enterting values in the textbox does not\n* Notice `x` is always 1\n* Watch how it updated `text1` and `text2` as needed.\n* Doesn't add 1 to text1 every time a new `text2` is input.\n* *Important* try `runApp(display.mode='showcase')` \n\n---\n## Reactive expressions\n* Sometimes to speed up your app, you want reactive operations (those operations that depend on widget input values) to be performed outside of a `render*`1 statement\n* For example, you want to do some code that gets reused in several \n`render*` statements and don't want to recalculate it for each\n* The `reactive` function is made for this purpose\n\n\n---\n## Example\n`server.R`\n```\nshinyServer(\n  function(input, output) {\n    x <- reactive({as.numeric(input$text1)+100})      \n    output$text1 <- renderText({x()                          })\n    output$text2 <- renderText({x() + as.numeric(input$text2)})\n  }\n)\n```\n\n---\n## As opposed to\n```\nshinyServer(\n  function(input, output) {\n    output$text1 <- renderText({as.numeric(input$text1)+100  })\n    output$text2 <- renderText({as.numeric(input$text1)+100 + \n        as.numeric(input$text2)})\n  }\n)\n```\n\n---\n## Discussion\n* Do `runApp(display.mode='showcase')` \n* (While inconsequential) the second example has to add 100 twice every time\ntext1 is updated for the second set of code\n* Also note the somewhat odd syntax for reactive variables\n\n\n---\n## Non-reactive reactivity (what?)\n* Sometimes you don't want shiny to immediately perform reactive\ncalculations from widget inputs\n* In other words, you want something like a submit button\n\n---\n## ui.R\n```\nshinyUI(pageWithSidebar(\n  headerPanel(\"Hello Shiny!\"),\n  sidebarPanel(\n      textInput(inputId=\"text1\", label = \"Input Text1\"),\n      textInput(inputId=\"text2\", label = \"Input Text2\"),\n      actionButton(\"goButton\", \"Go!\")\n  ),\n  mainPanel(\n      p('Output text1'),\n      textOutput('text1'),\n      p('Output text2'),\n      textOutput('text2'),\n      p('Output text3'),\n      textOutput('text3')\n  )\n))\n```\n\n---\n## Server.R\n```\nshinyServer(\n  function(input, output) {\n    output$text1 <- renderText({input$text1})\n    output$text2 <- renderText({input$text2})\n    output$text3 <- renderText({\n        input$goButton\n        isolate(paste(input$text1, input$text2))\n    })\n  }\n)\n```\n\n---\n## Try it out\n* Notice it doesn't display output `text3` until the go button is pressed\n* `input$goButton` (or whatever you named it) gets increased by one for every\ntime pushed\n* So, when in reactive code (such as `render` or `reactive`) you can use conditional statements like below to only execute code on the first button press or to not execute code until the first or subsequent button press\n\n```if (input$goButton == 1){  Conditional statements }``` \n\n\n---\n## Example\nHere's some replaced code from our previous `server.R` \n```\noutput$text3 <- renderText({\n    if (input$goButton == 0) \"You have not pressed the button\"\n    else if (input$goButton == 1) \"you pressed it once\"\n    else \"OK quit pressing it\"\n})\n```\n\n---\n## More on layouts\n* The sidebar layout with a main panel is the easiest.\n* Using `shinyUI(fluidpage(` is much more flexible and allows \ntighter access to the bootstrap styles\n* Examples here (http://shiny.rstudio.com/articles/layout-guide.html)\n* `fluidRow` statements create rows and then the `column` function\nfrom within it can create columns\n* Tabsets, navlists and navbars can be created for more complex apps\n\n---\n### Directly using html\n* For more complex layouts, direct use of html is preferred\n    (http://shiny.rstudio.com/articles/html-ui.html)\n* Also, if you know web development well, you might find using\nR to create web layouts kind of annoying\n* Create a directory called `www` in the same directory with `server.R`\n* Have an `index.html` page in that directory\n* Your named input variables will be passed to `server.R`\n`<input type=\"number\" name=\"n\" value=\"500\" min=\"1\" max=\"1000\" />`\n* Your `server.R` output will have class definitions of the form `shiny-`\n`<pre id=\"summary\" class=\"shiny-text-output\"></pre>`\n\n---\n## Debugging techniques for Shiny\n* Debugging shiny apps can be tricky\n* We saw that `runApp(displayMode = 'showcase')` highlights execution while a \nshiny app runs\n* Using `cat` in your code displays output to stdout (so R console)\n* The `browser()` function can interupt execution and can be called conditionally\n(http://shiny.rstudio.com/articles/debugging.html)\n\n\n",
    "created" : 1456167702808.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "519828224",
    "id" : "BA6434CD",
    "lastKnownWriteTime" : 1454354849,
    "path" : "~/GitHub/courses/09_DevelopingDataProducts/shiny2/index.Rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}